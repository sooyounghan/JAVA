-----
### java.util.Function Package
-----
1. 일반적으로 자주 쓰이는 형식의 메서드를 함수형 인터페이스로 미리 정의
2. java.util.Function 패키지의 주요 함수형 인터페이스
<div align="center">
<img src="https://github.com/sooyounghan/Java/assets/34672301/f18a8125-a556-4988-a976-ddf28520180f">
</div>

  - 타입 문자 'T'는 'Type', 'R'는 'Return Type'
    
3. 매개변수의 반환값의 유무에 따라 4개의 함수형 인터페이스 정의
4. Function의 변형으로 Predicate가 존재하는데, 반환값이 boolean이라는 것만 제외하면 Function과 동일
   - Predicate는 조건식을 함수로 표현하는데 사용

-----
### 조건식 표현에 사용되는 Predicate
-----
1. Predicate는 Function의 변형으로, 반환타입이 boolean
2. 조건식을 람다식으로 표현하는데 사용
   - 수학에서 결과로 true, false를 반환하는 함수를 Predicate
```java
Predicate<String> isEmptyStr = s -> s.length == 0;
String s = '";

if(isEmptyStr.test(s)) // if(s.length() == 0)
    System.out.println("This is an empty String.");
```

-----
### 매개변수가 두 개인 함수형 인터페이스
-----
1. 매개변수 개수가 2개인 함수형 인터페이스는 이름 앞 접두사 'Bi'가 붙음
2. 종류
<div align="center">
<img src="https://github.com/sooyounghan/Java/assets/34672301/ef3afaca-26a5-4645-a6f2-25192acc26eb">
</div>

  - Supplier는 매개변수가 없고 반환값만 존재하는데, 메서드는 두 개의 값을 반환할 수 없으므로 BiSupplier는 없음

3. 두 개 이상의 매개변수를 갖는 함수형 인터페이스가 필요하다면, 직접 만들어야함
   - 만약, 3개의 맥변수를 갖는 함수형 인터페이스 선언하면 다음과 같음
```java
@FunctionInterface
interface TriFunction<T, U, V, R> {
    R apply(T t, U u, V v);
}
```

-----
### UnaryOperator와 BinaryOperator
-----
1. Function의 또 다른 변형
2. 매개변수 타입과 반환타입이 모두 일치하는 점을 제외하고는 Function과 동일
3. UnaryOperator는 Function이 조상, BinaryOperator는 BiFunction이 조상
4. 종류
<div align="center">
<img src="https://github.com/sooyounghan/Java/assets/34672301/e8213cb7-e445-4b48-89d7-041fa23f5f54">
</div>

-----
### 컬렉션 프레임워크와 함수형 인터페이스
-----
1. 컬렉션 프레임워크 인터페이스에는 다수의 디폴트 메서드가 존재하는데, 이 중 일부는 함수형 인터페이스 사용
2. 컬렉션 프레임워크에서 함수형 인터페이스를 사용하는 메서드
<div align="center">
<img src="https://github.com/sooyounghan/Java/assets/34672301/cac21839-db89-4488-b173-85c950bc818b">
</div>

  - Map 인터페이스에 있는 'compute'로 시작하는 메서드들은 맵의 value 반환
  - merge()는 Map을 병합

3. 예시
```java
import java.util.*;

class LambdaEx4 {
	public static void main(String[] args) 	{
		ArrayList<Integer> list = new ArrayList<>();
		for(int i=0;i<10;i++)
			list.add(i);

		// list의 모든 요소 출력
		list.forEach(i->System.out.print(i+","));
		System.out.println();

		// list에서 2 또는 3의 배수 제거
		list.removeIf(x-> x%2==0 || x%3==0);
		System.out.println(list);

		list.replaceAll(i->i*10); // list의 각 요소에 10을 곱함
		System.out.println(list);

		Map<String, String> map = new HashMap<>();
		map.put("1", "1");
		map.put("2", "2");
		map.put("3", "3");
		map.put("4", "4");

		// map의 모든 요소를 {k, v}의 형식으로 출력
		map.forEach((k,v)-> System.out.print("{"+k+","+v+"},"));
		System.out.println();
	}
}
```
<div align="center">
<img src="https://github.com/sooyounghan/Java/assets/34672301/460ef8cc-ed73-40e1-9fc0-a4b66f821fe6">
</div>

```java
import java.util.function.*;
import java.util.*;

class LambdaEx5 {
	public static void main(String[] args) {
		Supplier<Integer>  s = ()-> (int)(Math.random()*100)+1;
		Consumer<Integer>  c = i -> System.out.print(i+", "); 
		Predicate<Integer> p = i -> i%2==0; 
		Function<Integer, Integer> f = i -> i/10*10; // i의 일의 자리 제거

		List<Integer> list = new ArrayList<>();	
		makeRandomList(s, list);
		System.out.println(list);
		printEvenNum(p, c, list);
		List<Integer> newList = doSomething(f, list);
		System.out.println(newList);
	}

	static <T> List<T> doSomething(Function<T, T> f, List<T> list) {
		List<T> newList = new ArrayList<T>(list.size());

		for(T i : list) {
			newList.add(f.apply(i));
		}	

		return newList;
	}

	static <T> void printEvenNum(Predicate<T> p, Consumer<T> c, List<T> list) {
		System.out.print("[");
		for(T i : list) {
			if(p.test(i))
				c.accept(i);
		}	
		System.out.println("]");
	}

	static <T> void makeRandomList(Supplier<T> s, List<T> list) {
		for(int i=0;i<10;i++) {
			list.add(s.get());
		}
	}
}
```
<div align="center">
<img src="https://github.com/sooyounghan/Java/assets/34672301/8f94381d-d82c-4f68-85e1-510ab31295b4">
</div>

-----
### 기본형을 사용하는 함수형 인터페이스
-----
1. 효율적을 처리하기 위해 기본형을 사용하는 함수형 인터페이스들 제공
2. 종류
<div align="center">
<img src="https://github.com/sooyounghan/Java/assets/34672301/f2d9cefc-4fbf-4e41-96b1-cc5705d8be1a">
</div>

3. 예제
```java
import java.util.function.*;
import java.util.*;

class LambdaEx6 {
	public static void main(String[] args) {
		IntSupplier  s = ()-> (int)(Math.random()*100)+1;
		IntConsumer  c = i -> System.out.print(i+", "); 
		IntPredicate p = i -> i%2==0; 
		IntUnaryOperator op = i -> i/10*10; // i의 일이 자리를 없앰

		int[] arr = new int[10];

		makeRandomList(s, arr);
		System.out.println(Arrays.toString(arr));
		printEvenNum(p, c, arr);
		int[] newArr = doSomething(op, arr);
		System.out.println(Arrays.toString(newArr));
	}

	static void makeRandomList(IntSupplier s, int[] arr) {
		for(int i=0;i<arr.length;i++) {
			arr[i] = s.getAsInt();  // get()이 아니라 getAsInt()임을 주의
		}
	}

	static void printEvenNum(IntPredicate p, IntConsumer c, int[] arr) {
		System.out.print("[");
		for(int i : arr) {
			if(p.test(i))
				c.accept(i);
		}	
		System.out.println("]");
	}

	static int[] doSomething(IntUnaryOperator op, int[] arr) {
		int[] newArr = new int[arr.length];

		for(int i=0; i<newArr.length;i++) {
			newArr[i] = op.applyAsInt(arr[i]); // apply()가 아님을 주의
		}	

		return newArr;
	}
}
```
<div align="center">
<img src="https://github.com/sooyounghan/Java/assets/34672301/2dab7459-0edd-4109-85ea-053bdf48b6b9">
</div>

  - 위 예제에서 IntUnaryOperator 대신 Function을 사용하면 에러 발생
```java
Function f = (a) -> 2 * a; // Error. a의 타입을 알 수 없으므로 연산 불가
```

  - 매개변수 a와 반환 값의 타입을 추정할 수 없기 때문이므로 다음과 같이 지정
```java
Function<Integer, Integer> f = (a) -> 2 * a; // OK. 매개변수 타입과 반환타입이 Integer
```

  - Function 대신 IntFunction도 가능
  - 단, IntUnaryOperator가 Function과 IntFunction보다 오토박싱 & 언박싱의 횟수가 줄어들어 성능이 좋음
```java
IntFunction<Integer> f = (a) -> 2 * a; // OK. 매개변수 타입이 int, 반환 타입은 Integer
```

  - IntToIntFunction이 없는 이유는, IntUnaryOperator가 그 역할을 하기 떄문임

