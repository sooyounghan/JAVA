-----
### 함수형 인터페이스 (Functional Interface)
-----
1. 람다식은 익명 클래스의 객체와 동등
```java
(int a, int b) -> a > b ? a : b
```
```java
new Object() {
    int max(int a, int b) {
        return a > b ? a : b;
    }
}
```

2. 우선, 익명 객체의 주소를 f라는 참조변수에 저장하고 있다고 가정
```java
타입 f = (int a, int b) -> a > b ? a : b; // 참조 변수의 타입은?
```
  - 참조형이므로 클래스 또는 인터페이스가 가능
  - 람다식과 동등한 메서드가 정의되어 있는 것이어야 함

3. 예를 들어, max()라는 메서드가 정의된 MyFunction가 인터페이스가 정의되어 있다고 가정
```java
interface MyFunction {
    public abstrac int max(int a, int b);
}
```

4. 이 인터페이스를 구현한 익명 클래스의 객체는 다음과 같이 생성 가능
```java
MyFunction f = new MyFunction() {
    public int max(int a, int b) {
        return a > b ? a : b;
    }
};

int big = f.max(3, 5); // 익명 객체의 메서드 호출
```

5. 즉 다음과 같이 익명 객체를 람다식으로 대체 가능
```java
MyFunction f = (int a, int b) -> a > b ? a : b; // 익명 객체를 람다식으로 대체
int big = f.max(3, 5); // 익명 객체 메서드 호출
```

6. 💡 이처럼 대체 가능한 이유는, 람다식은 실제로 익명 객체이며, MyFunction 인터페이스를 구현한 익명 객체 메서드 max()와 람다식의 매개변수의 타입과 개수 그리고 반환값이 일치하기 때문임
7. 따라서, 인터페이스를 통해 람다식을 다루기로 결정하여으므로, 람다시을 다루기 위한 인터페이스를 '함수형 인터페이스(Functional Interface)'
```java
@FunctionalInterface
interface MyFunction { // 함수형 인터페이스 MyFunction 정의
    public abstract int max(int a, int b);
}
```

8. 단 함수형 인터페이스에는 오직 하나의 추상 메서드만 정의되어 있어야 한다는 제약 존재
   - 람다식과 인터페이스의 메서드가 1:1로 연결될 수 있기 때문임
   - 반면, static 메서드와 디폴트 메서드의 개수는 제약 없음

9. 예시
```java
List<String> list = Arrays.asList("abc", "aaa", "bbb", "ddd", "aaa");

Collections.sort(list, new Comparator<String>() {
    public int compare(String s1, String s2) {
        return s2.compareTo(s1);
    }
});
```

```java
List<String> list = Arrays.asList("abc", "aaa", "bbb", "ddd", "aaa");

Collections.sort(list, (s1, s2) -> s2.compareTo(s1));
```
