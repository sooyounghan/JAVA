-----
### 쓰레드 상태
-----
1. 쓰레드의 상태
<div align="center">
<img src="https://github.com/sooyounghan/Java/assets/34672301/cdd932ca-07f7-478c-ac9b-f8643d5e07d4">
<img src="https://github.com/sooyounghan/Java/assets/34672301/a53c45e3-2cab-4643-a5c2-b9f43ce4d3f4">
</div>

2. 쓰레드의 상태 순서 (번호의 순서대로 쓰레드가 실행되는 것은 아님)
```
A. 쓰레드를 생성하고 start()를 호출하며 바로 실행되는 것이 아니라 실행 대기열에 저장되어 자신의 차례가 될 때 까지 기다림
   실행대기열은 큐(Queue)와 같은 구조로 먼저 실행 대기열에 들어온 쓰레드가 먼저 실행

B. 실행 대기 상태에 있다가 자신의 차례가 되면 실행 상태

C. 주어진 실행시간이 다 되거나 yield()를 만나면, 다시 실행 대기 상태가 되고, 다음 차례의 쓰레드가 실행 상태가 됨

D. 실행 중 suspend(), sleep(), wait(), join(), I/O block에 의해 일시정지 상태가 될 수 있음
   - I/O block은 입출력 작업에서 발생한 지연 상태를 의미 (사용자의 입력을 기다리는 경우)
   - 이런 경우에는 일시정지 상태에 있다가, 사용자가 입력을 마치면 다시 실행 대기 상태가 됨

E. 지정된 일시정지 시간이 다 되거나(time-out), notify(), resume(), interrupt()가 호출되면 일시 정지 상태를 벗어남
   - 다시 실행 대기열에 저장되어 자신의 차례를 기다리게 됨

F. 실행을 모두 마치거나 stop()이 호출되면, 쓰레드는 소멸
```

3. 쓰레드의 스케줄링과 관련된 메서드
<div align="center">
<img src="https://github.com/sooyounghan/Java/assets/34672301/bb84e7f7-998b-4fd9-ab32-9156c4764535">
</div>

  - resume(), stop(), suspend()는 쓰레드를 교착 상태(Dead-lock) 상태로 만들기 쉽기 때문에 deprecated됨

-----
#### sleep(long millis)
-----
1. 쓰레드를 지정된 일정 시간 동안 멈추게 함
```java
static void sleep(long millis)
static void sleep(long millis, int nanos)
```
  - millis : 1000분의 1초
  - nanos : 10억분의 1초
  - 세밀하게 조정할 수 있지만, 어느 정도 오차가 발생할 수 있음

2. 예) 쓰레드가 0.0015초 동안 멈추게 하려면?
```java
try {
    Thread.sleep(1, 500000); // 쓰레드를 0.0015초 동안 일시 정지
} catch(InterruptedException e) { }
```

3. sleep()에 의해 일시정지 상태가 된 쓰레드는 지정된 시간이 다 되거나 interrupt()가 호출되며 InterruptedException이 발생해 잠에서 깨어나 실행 대기 상태가 됨
4. 따라서 sleep()을 호출할 때는 항상 try - catch문으로 예외 처리를 해줘야함

5. 예제
```java
 class ThreadEx12 {
	public static void main(String args[]) {
		ThreadEx12_1 th1 = new ThreadEx12_1();
		ThreadEx12_2 th2 = new ThreadEx12_2();

		th1.start();
		th2.start();

		try {
			th1.sleep(2000);	
		} catch(InterruptedException e) {}

		System.out.print("<<main 종료>>");
	} // main
}

class ThreadEx12_1 extends Thread {
	public void run() {
		for(int i=0; i < 300; i++) {
			System.out.print("-");
		}
		System.out.print("<<th1 종료>>");
	} // run()
}

class ThreadEx12_2 extends Thread {
	public void run() {
		for(int i=0; i < 300; i++) {
			System.out.print("|");
		}
		System.out.print("<<th2 종료>>");
	} // run()
}
```
<div align="center">
<img src="https://github.com/sooyounghan/Java/assets/34672301/a65718dc-e868-4425-b833-e9fbeb905571">
</div>

  - 💡 sleep()은 항상 현재 실행 중인 쓰레드에 동작하기 떄문에 th1.sleep(2000)과 같이 호출해도, 실제로 영향을 받는 것은 main 메서드를 실행하는 main 쓰레드
  - 💡 따라서, sleep()은 static으로 선언되어있으며, 참조변수로 선언하기 보다, Thread.sleep(2000);과 같이 호출
  - yield() 또한 static인 이유가 동일
