-----
### Javadoc.exe
-----
1. 소스코드의 주석 '/** ~ */'에 소스 코드에 대한 정보를 저장하고, 소스코드의 주석으로부터 HTML 문서를 생성해내는 프로그램을 만들어 사용
2. 애너테이션 조상인 Annotation 인터페이스 소스코드
<div align="center">
<img src="https://github.com/sooyounghan/Java/assets/34672301/cb572f94-bac7-4d4e-a7b8-fe8905cdabf1">
</div>

  - '/**'로 시작하는 주석 안에 소스코드에 대한 설명 존재
  - '@'이 붙은 태그는 미리 정의된 태그들을 이용해 주석 안에 정보를 저장하고, javadoc.exe 프로그램이 이 정보를 읽어서 문서를 작성하는데 사용

-----
### 애너테이션 (Annotation) (주석, 주해, 메모)
-----
1. 프로그램 소스코드 안 다른 프로그램을 위한 정보를 미리 약속된 형식으로 포함시킨 것
2. 주석(Comment)처럼 프로그래밍 언어에 영향을 미치지 않으면서도 다른 프로그램에게도 유용한 정보 제공
3. 예시
   - 자신이 작성한 소스코드 중 특정 메서드만 테스트하길 원한다면 '@Test'라는 애너테이션을 앞에 붙임
   - 즉, 이 메서드를 테스트해야 한다는 것을 테스트 프로그램에게 알리는 역할을 할 뿐, 메서드가 포함된 프로그램 자체에는 아무런 영향을 미치지 않음
```java
@Test // 이 메서드가 테스트 대상임을 테스트 프로그램에게 알림
public void method() {
    ...
}
```

4. 애너테이션은 JDK에서 기본적으로 제공하는 것과 다른 프로그램에서 제공하는 것들이 존재하는데, 어느 것이든 그저 약속된 형식으로 정보를 제공하면 됨
5. JDK에서 제공하는 표준 애너테이션은 주로 컴파일러를 위한 것으로 컴파일러에게 유용한 정보를 제공
  - 새로운 애너테이션을 정의할 때 사용하는 메타 애너테이션도 제공
  - JDK에서 제공하는 애너테이션은 'java.lang.annotaion' 패키지에 포함

-----
### 표준 애너테이션
-----
<div align="center">
<img src="https://github.com/sooyounghan/Java/assets/34672301/ab754b97-6573-42d2-8d02-2429a1208d6c">
</div>

-----
### @Override
-----
1. 메서드 앞에만 붙일 수 있는 애너테이션
2. 조상의 메서드를 오버라이딩하는 것을 컴파일러에게 알려주는 역할
3. 오버라이딩할 때 조상 메서드의 이름을 잘못 써도 컴파일러는 이를 잘못된 것인지 알지 못하고, 그저 새로운 이름의 메서드가 추가된 것으로 인식
   - 더불어, 실행 시에도 오류가 발생하지 않고, 조상의 메서드가 호출되므로 어디가 잘못되었는지 알아내기 어려움
```java
class Parent {
    void parentMethod() { }
}

class Child extends Parent {
    void parentmethod() { } // 오버라이딩 하려했으나 실수로 이름을 잘못 적음
}
```

```java
class Child extends Parent {
    @Override
    void parentmethod() {}
}
```

4. 하지만, 위 코드처럼 메서드 앞에 '@Override'라고 애너테이션을 붙이면, 컴파일러가 같은 이름의 메서드가 조상에 있는지 확인하고 없으면, 에러 메세지를 출력

```java
class Parent {
	void parentMethod() { }
}

class Child extends Parent {
	@Override
	void parentmethod() { } // 조상 메서드의 이름을 잘못 적음 
}
```

-----
### @Deprecated
-----
1. 더 이상 사용되지 않는 필드나 메서드에 '@Deprecated'를 붙임
2. 이 애너테이션이 붙은 대상은 다른 것으로 대체되었으니 더 이상 사용하지 않는 것을 권한다는 의미
3. 예) java.util.Date 클래스의 대부분 메서드는 '@Deprecated'가 붙어있음
```java
int getDate()
  Deprecated.
  As of JDK Version 1.1, replaced by Calendar.get(Calendar.DAY_OF_MONTH).
```
  - 이 메서드 대신에 JDK1.1부터 추가된 Calendar 클래스의 get() 사용 권장
4. 즉, 기존의 것 대신 새로 추가된 개선된 기능을 사용하도록 유도하는 것
5. 가능하면 '@Deprecated'가 붙은 것들은 되도록 사용하지 않아야 함
6. 만약, '@Deprecated'가 붙은 대상을 사용하는 코드를 작성하면 다음과 같은 메세지 출력
<div align="center">
<img src="https://github.com/sooyounghan/Java/assets/34672301/60037ed1-929c-4e0b-9a0a-a8d0286ceda5">
</div>

  - 해당 소스 파일이 deprecated된 대상을 사용하고 있으며, '-Xlink:deprecation'옵션을 붙여서 컴파일하면, 자세한 내용을 알 수 있다는 뜻

```java
class NewClass{
	int newField;

	int getNewField() { 
		return newField;
	}	

	@Deprecated
	int oldField;

	@Deprecated
	int getOldField() { 
		return oldField;
	}
}

class AnnotationEx2 {
	public static void main(String args[]) {
		NewClass nc = new NewClass();

		nc.oldField = 10;                     //@Depreacted가 붙은 대상 사용
		System.out.println(nc.getOldField()); //@Depreacted가 붙은 대상 사용
	}
}
```

7. 메세지가 나타나기는 했지만, 컴파일 및 실행에 문제가 없음 (즉, 붙은 대상을 사용하지 않도록 권장할 뿐, 강제성은 없기 때문임)

-----
### @FunctionalInterface
-----
1. 함수형 인터페이스(Functional Interface)를 선언할 때, 이 애너테이션을 붙이면 컴파일러가 함수형 인터페이스를 올바르게 선언했는지 확인하고, 잘못된 경우 에러를 발생
2. 필수는 아니지만, 붙이면 실수를 방지 가능
  - 함수형 인터페이스는 추상 메서드가 하나뿐이어야 한다는 제약 존재
```java
@FunctionalInterface
public interface Runnable {
    public abstract void run(); // 추상 메서드
}
```

