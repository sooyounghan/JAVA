-----
### 바이트 기반 보조스트림
-----
-----
### 1. FilterInputStream과 FilterOutputStream
-----
1. InputStream과 OutputStream의 자손이면서, 모든 보조스트림의 조상
2. 보조스트림은 자체적으로 입출력을 수행할 수 없으므로 기반 스트림을 필요로 함
3. FilterInputStream / FilterOutputStream 생성자
```java
protected FilterInputStream(InputStream in)
public FilterOutputStream(OutputStream out)
```

4. 모든 메서드들은 단순히 기반 스트림의 메서드를 그대로 호출하며, 자체로는 아무런 일을 하지 않음을 의미
5. 또한, 상속을 통해 원하는 작업을 수행하도록 읽고 쓰는 메서드들을 오버라이딩 해야함
```java
public class FilterInputStream extends InputStream {
    protected volatile InputStream in;

    protected FilterInputStream(InputStream in) {
        this.in = in;
    }

    public int read() throws IOException {
        return in.read();
    }
    ...
}
```

6. 생성자 FilterInputStream(InputStream in)는 접근제어자가 protected 이므로 FilterInputStream의 인스턴스를 생성해 사용할 수 없고, 상속을 통해 오버라이딩해야함
7. FilterInputStream / FilterOutputStream을 상속받아서 기반스트림에 보조 기능을 추가한 클래스
```
FilterInputStream의 자손 : BufferedInputStream, DataInputStream, PushbackInputStream 등
FilterOutputStream의 자손 : BufferedOutputStream, DataOutputStream, PrintStream 등
```

-----
### BufferedInputStream가 BufferedOutputStream
-----
1. 스트림의 입출력 효율을 높이기 위해 버퍼를 사용하는 보조 스트림
2. 한 바이트 씩 입출력 하는 것보다 버퍼(바이트 배열)를 이용해 한 번에 여러 바이트를 입출력하는 것이 빠르기 때문에, 대부분 입/출력 작업에서 사용
3. BufferedInputStream의 생성자
<div align="center">
<img src="https://github.com/sooyounghan/Java/assets/34672301/23ec597e-8c92-478c-9c19-25524e0cef49">
</div>

  - 버퍼 크기는 입력 소스로부터 한 번에 가져올 수 있는 데이터의 크기로 지정하면 좋음
  - 보통 입력 소스가 파일인 경우 8192Byte(8K) 정도의 크기로 하는 것이 보통이며, 버퍼의 크기를 변경해가며 테스트하면 최적 버퍼 크기 도출 가능
  - 프로그램에서 입력소스로부터 데이터를 읽기 위해 처음으로 read 메서드를 호출하면, BufferedIntputStream은 입력소스로부터 버퍼 만큼 데이터를 읽어다가 자신의 내부 버퍼에 저장
  - 프로그램에서는 BufferedInputStream 버퍼에 저장된 데이터를 읽으면 되는 것
  - 외부의 입력소스로부터 읽는 것보다 내부 버퍼로부터 읽는 것이 훨씬 빠르므로 작업 효율이 높아짐
  - 프로그램에서 버퍼에 저장된 모든 데이터를 다 읽고, 그 다음 데이터를 읽기 위해 read 메서드가 호출되면, BufferedInputStream은 입력소스로부터 다시 버퍼 크기 만큼 데이터를 읽어다 버퍼를 저장하는 작업이 계속해서 반복

4. BufferedOutputStream의 생성자와 메서드
<div align="center">
<img src="https://github.com/sooyounghan/Java/assets/34672301/6f5f665e-1d58-470e-a36d-ca3018e8fbdf">
</div>

  - 프로그램에서 write 메서드를 이용한 출력이 BufferedOutputStream에 저장
  - 버퍼가 가득 차면, 그 때 버퍼의 모든 내용을 출력 소스에 출력
  - 그리고는 버퍼를 지우고 다시 프로그램으로부터의 출력을 저장할 준비를 함
  - 버퍼가 가득찼을 떄만 출력소스에 출력을 하기 때문에, 마지막 출력 부분이 출력 소스에 쓰이지 못하고 BufferedOutputStream의 버퍼에 남아있는 채로 프로그램이 종료될 수 있음
  - 따라서, 모든 출력 작업을 마친 후 BufferedOutputStream에 close()나 flush()를 호출해 마지막 버퍼에 있는 모든 내용이 출력소스에 출력되도록 해야함

5. BufferedOutputStream의 close()는 flush()를 호출하여 버퍼의 내용을 출력 스트림에 쓰도록 한 후, BufferedOutputStream 인스턴스의 참조 변수에 null을 지정함으로써 사용하던 자원 반환

```java
 import java.io.*;

class BufferedOutputStreamEx1 {
	public static void main(String args[]) {
		try {
		     FileOutputStream fos = new FileOutputStream("123.txt");
		     // BufferedOutputStream의 버퍼 크기 : 5
		     BufferedOutputStream bos = new BufferedOutputStream(fos, 5);
		     // 파일 123.txt에 1부터 9까지 출력
		     for(int i='1'; i <= '9'; i++) {
			     bos.write(i);
		     }

		     fos.close();
		} catch (IOException e) {
		     e.printStackTrace();		
		}
	}
}
```
  - 123.txt에 1부터 9까지 출력하는 것이지만 5까지 밖에 출력되지 않음
  - 그 이유는 버퍼에 남아있는 데이터가 출력되지 못한 상태로 프로그램이 종료되었기 때문
<div align="center">
<img src="https://github.com/sooyounghan/Java/assets/34672301/eea04763-68d6-4a53-a2cc-05b0161beb25">
</div>

6. fos.close()로 닫아주긴 했지만, 이렇게 해서는 BufferedOutputStream의 버퍼의 내용들이 출력되지 않음
7. bos.close(); 같이 해서 BufferedOutputStream의 close()를 호출해줘야 버퍼에 남아있던 모든 내용이 출력
8. BufferedOutputStream의 close()는 기반 스트림인 FileOutputStream의 close()를 호출하므로 따로 호출해주지 않아도 됨
9. 아래는 BufferedOutputStream의 조상인 FilterOutputStream의 실제 소스 코드
    - close()는 flush()를 호출한 다음 기반 스트림의 close()를 호출하는 것을 알 수 있음
    - 따라서, BufferedOutputStream에서는 close()를 오버라이딩 없이 그대로 상속받았으므로 사용 가능
```java
public class FilterOutputStream extends OutputStream {
    protected OutputStream out;

    public FilterOutputStream(OutputStream out) {
          this.out = out;
    }

    ...

    public void close() throws IOException {
        try {
            flush();
        } catch(IOException ingored) { }
        out.close(); // 기반 스트림의 close() 호출
    }

   ...

}
```
  - 따라서, 보조스트림을 사용하면 기반스트림의 close()나 flush() 호출 필요 없이 단순히 보조 스트림의 close()를 호출하면 됨

-----
### DataInputStream과 DataOutputStream
-----
1. 역시 FilterInputStream과 FilterOutputStream의 자손
2. DataInputStream은 DataInput 인터페이스를, DataOutputStream은 DataOutput 인터페이스를 구현
3. 데이터를 읽고 쓰는데 있어, byte 단위가 아닌 깁노 자료형 단위로 읽고 쓸 수 있다는 장점 존재
4. DataOutputStream이 출력하는 형식은 각 기본 자료형 값을 16진수로 표현해 저장

5. DataInputStream의 생성자와 메서드
<div align="center">
<img src="https://github.com/sooyounghan/Java/assets/34672301/534d73a1-7a50-4832-949b-59ece06d332e">
</div>

6. DataOutputStream의 생성자와 메서드
<div align="center">
<img src="https://github.com/sooyounghan/Java/assets/34672301/6204f053-0ae0-4307-aed7-fc387ca3e27d">
</div>

```java
import java.io.*;

class DataInputStreamEx1 {
	public static void main(String args[]) {
		try {
			FileInputStream fis = new FileInputStream("sample.dat");
			DataInputStream dis = new DataInputStream(fis);

			System.out.println(dis.readInt());
			System.out.println(dis.readFloat());
			System.out.println(dis.readBoolean());
			dis.close();
		} catch (IOException e) {
			e.printStackTrace();		
  		}
	} // main
}
```
  - 출력한 값들은 이진 데이터(Binary Data)로 저장
  - 즉, 문자 데이터(Text Data)가 아니므로 문서 편집기로 열어봐도 해석 불가하므로, 16진수 코드로 볼 수 있는 프로그램이나 ByteArrayOutputStream 이용

```java
import java.io.*;
import java.util.Arrays;

class DataOutputStreamEx2 {
	public static void main(String args[]) {
		ByteArrayOutputStream bos = null;
		DataOutputStream      dos = null;

		byte[] result = null;

		try {
			bos = new ByteArrayOutputStream();
			dos = new DataOutputStream(bos);
			dos.writeInt(10);
			dos.writeFloat(20.0f);
			dos.writeBoolean(true);

			result = bos.toByteArray();

			String[] hex = new String[result.length];

			for(int i=0;i<result.length; i++) {
				if(result[i] < 0) { 
					hex[i] = String.format("%02x", result[i]+256);
				} else {
					hex[i] = String.format("%02x", result[i]);
				}
			}

			System.out.println("10진수  :" + Arrays.toString(result));
			System.out.println("16진수  :" + Arrays.toString(hex));

			dos.close();
		} catch (IOException e) {
			e.printStackTrace();		
		}
	} // main
}
```
  - 출력값
```
10진수  :[0, 0, 0, 10, 65, -96, 0, 0, 1]
16진수  :[00, 00, 00, 0a, 41, a0, 00, 00, 01]
```

  - ByteArrayOutputStream을 사용
  - 첫 번째 4byte : 0, 0, 0, 10은 writeInt(10)에 의해 출력
  - 두 번쨰 4byte : 65, -96, 0, 0은 writeFloat(20.0f)에 의해 출력
  - 세 번째 1byte : 1은 writeBoolean(true)에 의해 출력
  - 이처럼, ByteArrayInputStream/ByteArrayOutputStream을 사용하면, byte 단위 데이터 변환 및 조작이 가능

<div align="center">
<img src="https://github.com/sooyounghan/Java/assets/34672301/2935d4e5-60c2-4f04-ba7c-9b9419d61dbe>
</div>

7. 모든 bit의 값이 1인 1byte가 있다고 가정하자.
  - 왼쪽 첫 비트를 부호로 인식하지 않으면, 부호 없는 1byte가 되므로 범위는 0~255이므로 이 값은 최대값인 255
  - 부호로 인식하는 경우 범위는 -128~127이 되고, 이는 0보다 1작은 값인 -1
  - 따라서, 같은 데이터이지만 자바의 자료형의 범위가 byte이면 byte의 범위가 부호 있는 1byte 정수의 범위인 -128~127로 인식하므로 -1로 인식
  - 따라서, 이 값을 0~255 사이의 값으로 변환하려면 256을 더해줘야함
  - 예를 들어, -1의 경우, -1 + 256 = 255이며, 반대의 경우 빼주면 됨
  - 그러나, InputStream의 read()는 반환타입이 int이며 0~255의 값을 반환하므로 위 과정이 필요 없음
  - 반면에, read(byte[] b)같이 byte 배열을 사용하는 경우는 상황에 따라 0~255 범위의 값으로 변화할 필요가 있음

8. 💡 DataOutputStream write 메서드들로 기록한 데이터들은 DataInputStream의 read메서드들로만 읽어야 함
9. 단, 여러 가지 종류의 자료형을 출력할 경우, 반드시 쓰인 순서대로 읽어야함


  - 
