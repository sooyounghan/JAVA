-----
### 인터페이스 (Interface)
-----
1. 일종의 추상클래스를 의미
2. 추상클래스보다 추상화 정도가 높아서 추상 클래스와 달리 몸통울 갖춘 일반 메서드 또는 멤버변수를 구성원으로 가질 수 없음
3. 💡💡💡 오직 추상메서드와 상수만을 멤버로 가질 수 있으며, 그 외의 다른 어떠한 요소를 허용하지 않음
   - 추상클래스 : 부분적으로 완성도나 '미완성 설계도'
   - 인터페이스 : 구현된 것은 아무것도 없고 밑그림만 그려져 있는 '기본 설계도'

-----
### 인터페이스 (Interface) 작성
-----
1. 키워드로 class 대신 'interface' 사용
2. 클래스와 같이 접근제어자로 public 또는 default 사용 가능
```java
interface 인터페이스이름 {
    public static final 타입 상수이름 = 값;
    public abstract 메서드이름(매개변수 목록);
}
```
3. 인터페이스의 멤버들의 제약 사항
```
A. 모든 멤버변수는 public static final이어야 하며, 이를 생략 가능
B. 모든 메서드는 public abstract 이어야 하며, 이를 생략 가능 (static 메서드와 디폴트 메서드는 예외(JDK 1.8 이후)
```
  - 인터페이스에 정의된 모든 멤버에 예외없이 적용되는 사항이기 떄문에 제어자를 생략 가능
  - 생략된 제어자는 컴파일 시 컴파일러가 자동적으로 추가

4. 예제
```java
interface playingCard {
    public static final int SPADE = 4;
    final int DIAMOND = 3; // public static final int DIAMOND = 3;
    static int HEART = 2; // public static final int HEART = 2;
    int CLOVER = 1; // public static final int CLOVER = 1;

    public abstract String getCardNumber();
    String getCardKind(); // public abstract String getCardKind();
}
```

5. 본래 인터페이스의 모든 메서드는 추상 메서드이어야 하는데, JDK1.8부터 인터페이스에 static 메서드와 default 메서드의 추가를 허용하는 방법으로 변경

-----
### 인터페이스 (Interface) 상속
-----
1. 인터페이스는 인터페이스로부터만 상속 가능
2. 클래스와는 달리 다중상속, 즉 여러 개의 인터페이스로부터 상속 받는 것이 가능
3. 클래스의 Object 클래스와 인터페이스는 달리 최고 조상이 없음
```java
interface Movable {
    /* 지정된 위치(x, y)로 이동하는 기능의 메서드 */
    void move(int x, int y);
}

interface Attackable {
    /* 지정된 대상(u)을 공격하는 기능의 메서드 */
    void attack(Unit u);
}

interface Fightable extends Movable, Attackable { }
```
4. 클래스 상속과 마찬 가지로 자식 인터페이스는 조상 인터페이스에 정의된 멤버 모두 상속
   - 그러므로 Fightable은 정의된 멤버가 하나도 없지만, 조상 인터페이스로부터 받은 두 개의 추상 메서드를 멤버로 가짐
  
-----
### 인터페이스 (Interface) 구현
-----
1. 추상클래스처럼 그 자체로는 인스턴스르 생성할 수 없으며, 자신에 정의된 추상메서드의 몸통을 만들어주는 클래스를 작성해야 함
2. 인터페이스는 구현한다는 의미의 키워드 'implements'를 사용
   - 클래스는 확장한다는 의미의 키워드 'extends'
```java
class 클래스이름 implements 인터페이스이름 {
    // 인터페이스에 정의된 추상 메서드를 구현해야 함
}

class Fighter implements Fightable {
    public void move(int x, int y) { /* 내용 생략 */ }
    public void attack(Unit u) { /* 내용 생략 */ }
}
```
  - 이 때, Fight 클래스는 Fightable 인터페이스를 구현한다고 함

3. 만일, 구현하는 인터페이스의 메서드 중 일부만 구현한다면, abstract를 붙여서 추상 클래스로 선언해야함
```java
abstract class Fighter implements Fightable {
    public void move(int x, int y) { /* 내용 생략 */ }
    // void attack(Unit u) 미구현
}
```

4. 또한, 상속과 더불어 구현을 동시에 할 수 있음
```java
class Fighter extends Unit implements Fightable {
    public void move(int x, int y) { /* 내용 생략 */ }
    public void attack(Unit u) { /* 내용 생략 */ }
}
```

5. 인터페이스의 이름에는 주로 '~을 할 수 있는'의 의미인 'able'로 끝나는 것들이 많음
   - 어떠한 기능 또는 행위를 하는데 필요한 메서드를 제공한다는 의미를 강조하기 위함
   - 인터페이스를 구현한 클래스는 '~를 할 수 있는' 능력을 갖추었다는 의미를 말함
  
```java
class FighterTest {
	public static void main(String[] args) {
		Fighter f = new Fighter();

		if (f instanceof Unit)	{		
			System.out.println("f는 Unit클래스의 자손입니다.");
		}
		if (f instanceof Fightable) {	
			System.out.println("f는 Fightable인터페이스를 구현했습니다.");
		}
		if (f instanceof Movable) {		
			System.out.println("f는 Movable인터페이스를 구현했습니다.");
		}
		if (f instanceof Attackable) {	
			System.out.println("f는 Attackable인터페이스를 구현했습니다.");
		}
		if (f instanceof Object) {		
			System.out.println("f는 ObjectŬ클래스의 자손입니다.");
		}
	}
}

class Fighter extends Unit implements Fightable {
	public void move(int x, int y) { /* 내용 생략 */ }
	public void attack(Unit u) { /* 내용 생략 */ }
}

class Unit {
	int currentHP;	// 유닛 체력
	int x;			// 유닛 위치 (x 좌표)
	int y;			// 유닛 위치 (y 좌표)
}

interface Fightable extends Movable, Attackable { }
interface Movable {	void move(int x, int y);	}
interface Attackable {	void attack(Unit u); }
```
<div align="centeR">
<img src="https://github.com/sooyounghan/Java/assets/34672301/22bf8215-dd18-4795-8acf-d5575b3d12b0">
</div>

6. 예제의 사용된 클래스와 인터페이스의 관계
<div align="centeR">
<img src="https://github.com/sooyounghan/Java/assets/34672301/13e6db64-7147-458d-9cb8-e084bf39830c">
</div>

  - Fighter 클래스는 Unit 클래스로부터 상속받고 Fightable 인터페이스만을 구현
    + Unit 클래스는 Object 클래스의 자손
    + Fightable 인터페이스는 Attackable과 Movable 인터페이스의 자손
  - 따라서, 이 모든 클래스와 인터페이스의 자손이 되는 셈
  - 인터페이스는 상속 대신 구현이라는 용어를 쓰지만, 인터페이스로부터 상속받은 추상 메서드를 구현하는 것이므로 다른 의미의 조상

```java
interface Movable {
  void move(int x, int y);
}

class Fighter extends Unit implements Fightable {
    public void move(int x, int y) { /* 내용 생략 */ }
    public void attack(Unit u) { /* 내용 생략 */ }
}
```

7. 오버라이딩 할 때는 조상의 메서드보다 넓은 범위의 접근 제어자를 지정해야 함
   - Movable 인터페이스의 void move(int x, int y)는 사실 public abstract가 생략
   - 따라서, 이를 구현하는 Fighter 클래스는 void move(int x, int y)의 접근 제어자를 반드시 public으로 설정해야함
