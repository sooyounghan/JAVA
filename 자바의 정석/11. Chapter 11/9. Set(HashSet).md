-----
### HashSet
-----
1. Set 인터페이스를 구현한 가장 대표적인 컬렉션이며, Set인터페이스 특징대로 중복된 요소를 저장하지 않음
2. 새로운 요소를 추가할 때 add메서드나 addAll 메서드를 사용
   - 만일, HashSet에 이미 저장되어 있는 요소와 중복된 요소를 추가하고자 한다면, 해당 메서드들은 false를 반환(중복된 요소이기 때문에 추가 실패)
   - 따라서, 컬렉션 내의 중복 요소 쉽게 제거 가능
3. 저장 순서를 유지하지 않으므로, 저장 순서를 유지하고자 한다면, LinkedListHashSet 사용
4. 내부적으로 HashMap을 이용해 만들어졌으며, 해싱(Hashing)을 이용해서 구현했음
5. HashSet의 메서드
<div align="center">
<img src="https://github.com/sooyounghan/Java/assets/34672301/f30417fd-94ff-446d-b469-6cf5be9b2fed">
</div>

  - loadFactor : 컬렉션 클래스 저장공간이 가득 차기 전 미리 용량을 확보하기 위한 것 (기본값 0.75 / 즉, 75%)
  - 예시) loadFactor = 0.8 (저장 공간의 80%가 채워지면, 용량이 두 배로 늘어남)

-----
### HashSet 예제
-----
```java
import java.util.*;

class HashSetEx1 {
	public static void main(String[] args) {
		Object[] objArr = {"1",new Integer(1),"2","2","3","3","4","4","4"};
		Set set = new HashSet();

		for(int i=0; i < objArr.length; i++) {
			set.add(objArr[i]);	// HashSet에 objArr의 요소들을 저장.
		}
		// HashSet에 저장된 요소 출력
		System.out.println(set);	
	}
}
```
<div align="center">
<img src="https://github.com/sooyounghan/Java/assets/34672301/48242498-d033-432e-aa53-962b4836c737">
</div>

1. HashSet은 중복된 값을 저장하지 않으며, add메서드는 객체를 추가할 때 HashSet에 이미 같은 객체가 있으면 중복으로 간주하고 저장하지 않으며, 작업이 실패했다는 false를 반환
2. '1'이 두 번 출력 되었는데, 둘다 '1'로 보일 수 있음
   - '1'은 String 인스턴스
   - 다른 하나는 Integer 인스턴스
   - 즉, 다른 객체이므로 중복으로 간주하지 ㅇ낳음
3. 또한, 순서를 유지하지 않으므로 저장한 순서와 다를 수 있음
4. 중복을 제거하는 동시에 저장 순서를 유지하고 싶다면, LinkedListHashSet 이용

5. 중복된 값을 저장하지 않는 성질을 이용해 로또번호를 만드는 예제
```java
import java.util.*;

class HashSetLotto {
	public static void main(String[] args) {
		Set set = new HashSet();
		
		for (int i = 0; set.size() < 6 ; i++) {
			int num = (int)(Math.random()*45) + 1;
			set.add(new Integer(num));
		}

		List list = new LinkedList(set);	// LinkedList(Collection c)
		Collections.sort(list);				// Collections.sort(List list)
		System.out.println(list);
	}
}
```
<div align="center">
<img src="https://github.com/sooyounghan/Java/assets/34672301/a5925306-1a52-42ab-aac2-dc0747a00b63">
</div>

  - 번호를 크기순으로 정렬하기 위해 Collections 클래스의 sort(List list) 이용
  - 해당 메서드는 인자를 List 인터페이스 타입으로 받아 LinkedList 클래스의 생성자 LinkedList(Collection c)를 이용해 HashSet에 저장된 객체들을 LinkedList에 받아 처리
  - 정렬 기준은 컬렉션에 저장된 객체가 Integer이므로 Integer 클래스에 정의된 기본 정렬이 사용

6. 1 ~ 50 사이의 숫자 중 25개를 골라 5 x 5 크기의 빙고판을 만드는 예제
```java
import java.util.*; 

class Bingo { 
      public static void main(String[] args) { 
            Set set = new HashSet(); 
//          Set set = new LinkedHashSet(); 
            int[][] board = new int[5][5]; 

            for(int i=0; set.size() < 25; i++) { 
                  set.add((int)(Math.random()*50)+1+""); 
            } 

            Iterator it = set.iterator(); 

            for(int i=0; i < board.length; i++) { 
                  for(int j=0; j < board[i].length; j++) { 
                        board[i][j] = Integer.parseInt((String)it.next());
                        System.out.print((board[i][j] < 10 ? "  " : " ") + board[i][j]); 
                  } 
                  System.out.println(); 
            } 
      } // main
} 
```
<div align="center">
<img src="https://github.com/sooyounghan/Java/assets/34672301/c4d8aaa2-2550-4072-a060-1cb6a8c133e7">
</div>

  - next()의 반환값은 Object 타입이므로 형 변환하여 원래의 타입으로 형변환
  - 같은 숫자가 비슷한 위치에 나올 수 있는데, HashSet은 저장된 순서를 보장하지 않고 자체적인 저장방식에 따라 순서가 결정됨
  - 따라서, 이럴 경우 HashSet보다 LinkedList 방식이 더 나음
    
