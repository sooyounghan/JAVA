-----
### 와일드 카드
-----
1. 매개변수에 과일박스를 대입하면 주스를 만들어서 반환하는 Juicer라는 클래스가 있으며, 이 클래스에는 과일을 주스로 만들어서 반환하는 makeJuice()라는 static 메서드 존재한다고 가정
```java
class Juicer {
    static Juice makeJuice(FruitBox<Fruit> box) { // <Fruit>으로 지정
        String tmp = "";
        for(Fruit f : box.getList()) tmp += f + " ";
        return new Juice(tmp);
    }
}
```

2. Juicer 클래스는 지네릭 클래스가 아닌데다, 지네릭 클래스라해도 static 메서드에는 타입 매개변수 T를 매개변수로 사용할 수 없음
```java
FruitBox<Fruit> fruitBox = new FruitBox<Fruit>();
FruitBox<Apple> fruitBox = new FruitBox<Apple>();

...

System.out.println(Juicer.makeJuice(fruitBox)); // Ok. FruitBox<Fruit>
System.out.println(Juicer.makeJuice(appleBox)); // Error. FruitBox<Apple>
```

3. 이렇게 지네릭 타입을 '```FruitBox<Fruit>```'으로 고정해 놓으면, ```FruitBox<Apple>``` 타입의 객체는 makeJuice()의 매개변수가 될 수 없으므로, 다음과 같이 여러 가지 타입의 매개변수를 갖는 makeJuice()를 만들 수 밖에 없음
```java
static Juice makeJuice(FruitBox<Fruit> box) {
    String tmp = "";
    for(Fruit f : box.getList()) tmp += f + " ";
    return new Juice(tmp);
}

static Juice makeJuice(FruitBox<Apple> box) {
    String tmp = "";
    for(Fruit f : box.getList()) tmp += f + " ";
    return new Juice(tmp);
}
```

4. 하지만, 위와 같이 오버로딩 하면, 컴파일 에러가 발생
   - 💡 지네릭 타입이 다른 것만으로는 오버로딩이 성립하지 않음
   - 지네릭 타입은 컴파일러가 컴파일 할 때만 사용하고 제거해버림. 따라서, 메서드 중복 정의가 되어버림

5. 와일드 카드는 이러한 문제를 해결하기 위해 등장 (기호 ?로 표현하며, 와일드 카드는 어떠한 타입도 가능)

-----
### 와일드 카드의 제한
-----
1. ? 만으로는 Object 타입과 다를게 없으므로, extends와 super로 상한(Upper Bound)과 하한(Lower Bound)을 제한할 수 있음
```
<? extends T> : 와일드 카드의 상한 제한. T와 그 자손들만 가능
<? super T> : 와일드 카드의 하한 제한. T와 그 조상들만 가능
<?> : 제한 없음. 모든 타입이 가능, 즉 <? extends Object>와 동일
```
  - 단, 와일드 카드에는 & 사용 불가 (즉, <? extends T & E> 불가)

2. 따라서, makeJuice()의 매개변수 타입을 다음과 같이 변경 가능
```java
static Juice makeJuice(FruitBox<? extends Fruit> box) {
    String tmp = "";
    for(Fruit f : box.getList()) tmp += f + " ";
    return new Juice(tmp);
}
```

3. 이제 해당 메서드는 매개변수로 ```FruitBox<Fruit>``` 뿐만 아니라, ```FruitBox<Apple>```와 ```FruitBox<Grape>```도 가능
```java
FruitBox<Fruit> fruitBox = new FruitBox<Fruit>();
FruitBox<Apple> fruitBox = new FruitBox<Apple>();

...

System.out.println(Juicer.makeJuice(fruitBox)); // Ok. FruitBox<Fruit>
System.out.println(Juicer.makeJuice(appleBox)); // Ok. FruitBox<Apple>
```

4. 매개변수 타입을 ```FruitBox<? extends Object>```로 하면, 모든 종류의 FruitBox가 이 메서드의 매개변수로 가능
   - 대신, 전과 달리 box의 요소가 Fruit의 자손이라는 보장이 없으므로 아래의 for문에서 box에 저장된 요소를 Fruit 타입의 참조변수로 받지 못함
```java
static Juice makeJuice(FruitBox<? extends Fruit> box) {
    String tmp = "";
    for(Fruit f : box.getList()) tmp += f + " "; // Error. Fruit이 아닐 수 있음
    return new Juice(tmp);
}
```

5. 하지만, 실제로 문제 없이 컴파일이 되는데, 이유는 바로 지네릭 클래스 FruitBox로 제한했기 때문임
```java
class FruitBox<T extends Fruit> extends Box<T> { }
```

6. 즉, 컴파일러는 위 문장으로부터 모든 FruitBox의 요소들이 Fruit의 자손이라는 것을 알고 있으므로 문제가 되지 않음
